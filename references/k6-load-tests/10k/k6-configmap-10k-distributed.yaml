---
# Part 1: 3.3k RPS
apiVersion: v1
kind: ConfigMap
metadata:
  name: k6-script-10k-part1
  namespace: load-test
  labels:
    app.kubernetes.io/name: load-test-cm
    app.kubernetes.io/component: load-test
    part: "1"
data:
  script.js: |
    import http from 'k6/http';
    import { check, sleep } from 'k6';
    import { Rate, Counter } from 'k6/metrics';

    // Custom Metric
    const queueJoinFailRate = new Rate('queue_join_fail_rate');
    const queueStatusFailRate = new Rate('queue_status_fail_rate');
    const queueEnterFailRate = new Rate('queue_enter_fail_rate');
    const reservationFailRate = new Rate('reservation_fail_rate');
    const paymentFailRate = new Rate('payment_fail_rate');
    const completedFlows = new Counter('completed_flows');

    function uuidv4() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    export const options = {
        scenarios: {
          full_success_flow: {
              executor: 'ramping-arrival-rate',
              startRate: 0,
              timeUnit: '1s',
              preAllocatedVUs: 100,
              maxVUs: 1500,
              stages: [
                  { duration: '2m', target: 1000 },   // Ramp up: 0 -> 1k
                  { duration: '5m', target: 3300 },   // Ramp up: 1k -> 3.3k
                  { duration: '10m', target: 3300 },  // Hold: 3.3k
                  { duration: '3m', target: 0 },      // Ramp down: 3.3k -> 0
              ],
              exec: 'fullScenario',
              tags: { part: '1' }
          }
        },
        thresholds: {
            http_req_duration: ['p(95)<5000', 'p(99)<7000'],
            http_req_failed: ['rate<0.1'],
            queue_join_fail_rate: ['rate<0.05'],
            queue_status_fail_rate: ['rate<0.2'],
            queue_enter_fail_rate: ['rate<0.2'],
        }
    };

    const BASE_URL = __ENV.TARGET_BASE_URL;
    const API_PREFIX = '/api/v1';
    const PART_ID = __ENV.PART_ID || '1';

    const baseHeaders = {
        'Content-Type': 'application/json'
    };

    // 공통 함수: 대기열 진입
    function joinQueue() {
        const userId = `u${uuidv4()}`;
        const eventId = `evt_${Math.floor(Math.random() * 100) + 1}`;
        
        const joinRes = http.post(
            `${BASE_URL}${API_PREFIX}/queue/join`,
            JSON.stringify({
                user_id: userId,
                event_id: eventId,
            }),
            {
                headers: {
                    ...baseHeaders,
                    'Idempotency-Key': uuidv4(),
                },
                timeout: '30s',
                tags: { name: 'queue_join', part: PART_ID }
            }
        );
        
        const success = check(joinRes, {
            'queue join status 202': (r) => r.status === 202,
            'queue join has token': (r) => r.json('waiting_token') !== undefined,
        });

        queueJoinFailRate.add(!success);
        
        return success ? { waiting_token: joinRes.json('waiting_token'), userId, eventId } : null;
    }

    // 공통 함수: 대기열 상태 폴링
    function pollQueueStatus(waiting_token, maxAttempts = 30) {
        for (let i = 0; i < maxAttempts; i++) {
            sleep(Math.random() * 2 + 2); // 2-4초
            
            const statusRes = http.get(
                `${BASE_URL}${API_PREFIX}/queue/status?token=${waiting_token}`,
                { tags: { name: 'queue_status', part: PART_ID } }
            );
                
            if (statusRes.status === 200 && statusRes.json('status') === "ready") {
                return true;
            }
            queueStatusFailRate.add(statusRes.status !== 200);
        }
        queueStatusFailRate.add(true);
        return false;
    }

    // 공통 함수: 시스템 진입
    function enterSystem(waiting_token) {
        const enterRes = http.post(
            `${BASE_URL}${API_PREFIX}/queue/enter`,
            JSON.stringify({ waiting_token }),
            {
                headers: {
                    ...baseHeaders,
                    'Idempotency-Key': uuidv4(),
                },
                tags: { name: 'queue_enter', part: PART_ID }
            }
        );
        
        const success = check(enterRes, {
            'queue enter status 200': (r) => r.status === 200,
            'queue enter has reservation token': (r) => r.json('reservation_token') !== undefined,
        });
        queueEnterFailRate.add(!success);
        
        return success ? enterRes.json('reservation_token') : null;
    }

    // 공통 함수: 예약 생성
    function createReservation(accessToken, eventId) {
        const authHeaders = {
            ...baseHeaders,
            'Authorization': `Bearer ${accessToken}`,
        };
        
        const reserveRes = http.post(
            `${BASE_URL}${API_PREFIX}/reservations`,
            JSON.stringify({
                event_id: eventId,
                seat_ids: [
                    "A-" + (Math.floor(Math.random() * 1000) + 1),
                    "A-" + (Math.floor(Math.random() * 1000) + 1),
                ],
                "quantity": 2
            }),
            { 
                headers: {
                    ...authHeaders,
                    'Idempotency-Key': uuidv4(),
                },
                tags: { name: 'create_reservation', part: PART_ID }
            }
        );
        
        const success = check(reserveRes, {
            'reservation created': (r) => r.status === 201 || r.status === 200,
            'reservation has id': (r) => r.json('reservation_id') !== undefined,
        });
        reservationFailRate.add(!success);
        
        return success ? { reservationId: reserveRes.json('reservation_id'), authHeaders } : null;
    }

    export function fullScenario() {
        const queueData = joinQueue();
        if (!queueData) return;
        
        const ready = pollQueueStatus(queueData.waiting_token);
        if (!ready) return;
        
        const accessToken = enterSystem(queueData.waiting_token);
        if (!accessToken) return;
        
        sleep(Math.random() * 2 + 1);
        const reservation = createReservation(accessToken, queueData.eventId);
        if (!reservation) return;
        
        completedFlows.add(1);
        
        sleep(Math.random() * 1 + 0.5);
    }
---
# Part 2: 3.3k RPS (동일한 스크립트, 태그만 다름)
apiVersion: v1
kind: ConfigMap
metadata:
  name: k6-script-10k-part2
  namespace: load-test
  labels:
    app.kubernetes.io/name: load-test-cm
    app.kubernetes.io/component: load-test
    part: "2"
data:
  script.js: |
    import http from 'k6/http';
    import { check, sleep } from 'k6';
    import { Rate, Counter } from 'k6/metrics';

    const queueJoinFailRate = new Rate('queue_join_fail_rate');
    const queueStatusFailRate = new Rate('queue_status_fail_rate');
    const queueEnterFailRate = new Rate('queue_enter_fail_rate');
    const reservationFailRate = new Rate('reservation_fail_rate');
    const completedFlows = new Counter('completed_flows');

    function uuidv4() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    export const options = {
        scenarios: {
          full_success_flow: {
              executor: 'ramping-arrival-rate',
              startRate: 0,
              timeUnit: '1s',
              preAllocatedVUs: 100,
              maxVUs: 1500,
              stages: [
                  { duration: '2m', target: 1000 },
                  { duration: '5m', target: 3300 },
                  { duration: '10m', target: 3300 },
                  { duration: '3m', target: 0 },
              ],
              exec: 'fullScenario',
              tags: { part: '2' }
          }
        },
        thresholds: {
            http_req_duration: ['p(95)<5000', 'p(99)<7000'],
            http_req_failed: ['rate<0.1'],
        }
    };

    const BASE_URL = __ENV.TARGET_BASE_URL;
    const API_PREFIX = '/api/v1';
    const PART_ID = __ENV.PART_ID || '2';
    const baseHeaders = { 'Content-Type': 'application/json' };

    function joinQueue() {
        const userId = `u${uuidv4()}`;
        const eventId = `evt_${Math.floor(Math.random() * 100) + 1}`;
        const joinRes = http.post(`${BASE_URL}${API_PREFIX}/queue/join`, JSON.stringify({ user_id: userId, event_id: eventId }), {
            headers: { ...baseHeaders, 'Idempotency-Key': uuidv4() },
            timeout: '30s',
            tags: { name: 'queue_join', part: PART_ID }
        });
        const success = check(joinRes, { 'join ok': (r) => r.status === 202 });
        queueJoinFailRate.add(!success);
        return success ? { waiting_token: joinRes.json('waiting_token'), userId, eventId } : null;
    }

    function pollQueueStatus(token) {
        for (let i = 0; i < 30; i++) {
            sleep(Math.random() * 2 + 2);
            const res = http.get(`${BASE_URL}${API_PREFIX}/queue/status?token=${token}`, { tags: { name: 'queue_status', part: PART_ID } });
            if (res.status === 200 && res.json('status') === "ready") return true;
            queueStatusFailRate.add(res.status !== 200);
        }
        return false;
    }

    function enterSystem(token) {
        const res = http.post(`${BASE_URL}${API_PREFIX}/queue/enter`, JSON.stringify({ waiting_token: token }), {
            headers: { ...baseHeaders, 'Idempotency-Key': uuidv4() },
            tags: { name: 'queue_enter', part: PART_ID }
        });
        const success = check(res, { 'enter ok': (r) => r.status === 200 });
        queueEnterFailRate.add(!success);
        return success ? res.json('reservation_token') : null;
    }

    function createReservation(token, eventId) {
        const res = http.post(`${BASE_URL}${API_PREFIX}/reservations`, JSON.stringify({
            event_id: eventId,
            seat_ids: ["A-" + (Math.floor(Math.random() * 1000) + 1), "A-" + (Math.floor(Math.random() * 1000) + 1)],
            quantity: 2
        }), {
            headers: { ...baseHeaders, 'Authorization': `Bearer ${token}`, 'Idempotency-Key': uuidv4() },
            tags: { name: 'create_reservation', part: PART_ID }
        });
        const success = check(res, { 'reservation ok': (r) => r.status === 201 || r.status === 200 });
        reservationFailRate.add(!success);
        return success ? res.json('reservation_id') : null;
    }

    export function fullScenario() {
        const queueData = joinQueue();
        if (!queueData) return;
        if (!pollQueueStatus(queueData.waiting_token)) return;
        const token = enterSystem(queueData.waiting_token);
        if (!token) return;
        sleep(Math.random() * 2 + 1);
        if (createReservation(token, queueData.eventId)) {
            completedFlows.add(1);
        }
        sleep(Math.random() * 1 + 0.5);
    }
---
# Part 3: 3.4k RPS
apiVersion: v1
kind: ConfigMap
metadata:
  name: k6-script-10k-part3
  namespace: load-test
  labels:
    app.kubernetes.io/name: load-test-cm
    app.kubernetes.io/component: load-test
    part: "3"
data:
  script.js: |
    import http from 'k6/http';
    import { check, sleep } from 'k6';
    import { Rate, Counter } from 'k6/metrics';

    const queueJoinFailRate = new Rate('queue_join_fail_rate');
    const queueStatusFailRate = new Rate('queue_status_fail_rate');
    const queueEnterFailRate = new Rate('queue_enter_fail_rate');
    const reservationFailRate = new Rate('reservation_fail_rate');
    const completedFlows = new Counter('completed_flows');

    function uuidv4() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    export const options = {
        scenarios: {
          full_success_flow: {
              executor: 'ramping-arrival-rate',
              startRate: 0,
              timeUnit: '1s',
              preAllocatedVUs: 100,
              maxVUs: 1500,
              stages: [
                  { duration: '2m', target: 1000 },
                  { duration: '5m', target: 3400 },   // 3.4k (나머지)
                  { duration: '10m', target: 3400 },
                  { duration: '3m', target: 0 },
              ],
              exec: 'fullScenario',
              tags: { part: '3' }
          }
        },
        thresholds: {
            http_req_duration: ['p(95)<5000', 'p(99)<7000'],
            http_req_failed: ['rate<0.1'],
        }
    };

    const BASE_URL = __ENV.TARGET_BASE_URL;
    const API_PREFIX = '/api/v1';
    const PART_ID = __ENV.PART_ID || '3';
    const baseHeaders = { 'Content-Type': 'application/json' };

    function joinQueue() {
        const userId = `u${uuidv4()}`;
        const eventId = `evt_${Math.floor(Math.random() * 100) + 1}`;
        const joinRes = http.post(`${BASE_URL}${API_PREFIX}/queue/join`, JSON.stringify({ user_id: userId, event_id: eventId }), {
            headers: { ...baseHeaders, 'Idempotency-Key': uuidv4() },
            timeout: '30s',
            tags: { name: 'queue_join', part: PART_ID }
        });
        const success = check(joinRes, { 'join ok': (r) => r.status === 202 });
        queueJoinFailRate.add(!success);
        return success ? { waiting_token: joinRes.json('waiting_token'), userId, eventId } : null;
    }

    function pollQueueStatus(token) {
        for (let i = 0; i < 30; i++) {
            sleep(Math.random() * 2 + 2);
            const res = http.get(`${BASE_URL}${API_PREFIX}/queue/status?token=${token}`, { tags: { name: 'queue_status', part: PART_ID } });
            if (res.status === 200 && res.json('status') === "ready") return true;
            queueStatusFailRate.add(res.status !== 200);
        }
        return false;
    }

    function enterSystem(token) {
        const res = http.post(`${BASE_URL}${API_PREFIX}/queue/enter`, JSON.stringify({ waiting_token: token }), {
            headers: { ...baseHeaders, 'Idempotency-Key': uuidv4() },
            tags: { name: 'queue_enter', part: PART_ID }
        });
        const success = check(res, { 'enter ok': (r) => r.status === 200 });
        queueEnterFailRate.add(!success);
        return success ? res.json('reservation_token') : null;
    }

    function createReservation(token, eventId) {
        const res = http.post(`${BASE_URL}${API_PREFIX}/reservations`, JSON.stringify({
            event_id: eventId,
            seat_ids: ["A-" + (Math.floor(Math.random() * 1000) + 1), "A-" + (Math.floor(Math.random() * 1000) + 1)],
            quantity: 2
        }), {
            headers: { ...baseHeaders, 'Authorization': `Bearer ${token}`, 'Idempotency-Key': uuidv4() },
            tags: { name: 'create_reservation', part: PART_ID }
        });
        const success = check(res, { 'reservation ok': (r) => r.status === 201 || r.status === 200 });
        reservationFailRate.add(!success);
        return success ? res.json('reservation_id') : null;
    }

    export function fullScenario() {
        const queueData = joinQueue();
        if (!queueData) return;
        if (!pollQueueStatus(queueData.waiting_token)) return;
        const token = enterSystem(queueData.waiting_token);
        if (!token) return;
        sleep(Math.random() * 2 + 1);
        if (createReservation(token, queueData.eventId)) {
            completedFlows.add(1);
        }
        sleep(Math.random() * 1 + 0.5);
    }
