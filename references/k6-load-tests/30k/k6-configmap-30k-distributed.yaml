---
# ConfigMap Template for 30k RPS Distributed Test
# Each part handles 5k RPS
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: k6-script-30k-part1
  namespace: load-test
  labels:
    app.kubernetes.io/name: load-test-cm
    test: 30k-distributed
    part: "1"
data:
  script.js: |
    import http from 'k6/http';
    import { check, sleep } from 'k6';
    import { Rate, Counter } from 'k6/metrics';

    const queueJoinFailRate = new Rate('queue_join_fail_rate');
    const queueStatusFailRate = new Rate('queue_status_fail_rate');
    const queueEnterFailRate = new Rate('queue_enter_fail_rate');
    const reservationFailRate = new Rate('reservation_fail_rate');
    const completedFlows = new Counter('completed_flows');

    function uuidv4() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    export const options = {
        scenarios: {
          full_success_flow: {
              executor: 'ramping-arrival-rate',
              startRate: 0,
              timeUnit: '1s',
              preAllocatedVUs: 200,
              maxVUs: 2500,
              stages: [
                  { duration: '3m', target: 2000 },   // Warm-up: 0 -> 2k
                  { duration: '5m', target: 5000 },   // Ramp-up: 2k -> 5k
                  { duration: '15m', target: 5000 },  // Hold: 5k
                  { duration: '3m', target: 0 },      // Ramp-down
              ],
              exec: 'fullScenario',
              tags: { part: '1', test: '30k' }
          }
        },
        thresholds: {
            http_req_duration: ['p(95)<5000', 'p(99)<8000'],
            http_req_failed: ['rate<0.15'],
        }
    };

    const BASE_URL = __ENV.TARGET_BASE_URL;
    const API_PREFIX = '/api/v1';
    const PART_ID = __ENV.PART_ID || '1';
    const baseHeaders = { 'Content-Type': 'application/json' };

    function joinQueue() {
        const userId = `u${uuidv4()}`;
        const eventId = `evt_${Math.floor(Math.random() * 100) + 1}`;
        const joinRes = http.post(`${BASE_URL}${API_PREFIX}/queue/join`, JSON.stringify({ user_id: userId, event_id: eventId }), {
            headers: { ...baseHeaders, 'Idempotency-Key': uuidv4() },
            timeout: '30s',
            tags: { name: 'queue_join', part: PART_ID, test: '30k' }
        });
        const success = check(joinRes, { 'join ok': (r) => r.status === 202 });
        queueJoinFailRate.add(!success);
        return success ? { waiting_token: joinRes.json('waiting_token'), userId, eventId } : null;
    }

    function pollQueueStatus(token) {
        for (let i = 0; i < 30; i++) {
            sleep(Math.random() * 2 + 2);
            const res = http.get(`${BASE_URL}${API_PREFIX}/queue/status?token=${token}`, { 
                tags: { name: 'queue_status', part: PART_ID, test: '30k' } 
            });
            if (res.status === 200 && res.json('status') === "ready") return true;
            queueStatusFailRate.add(res.status !== 200);
        }
        return false;
    }

    function enterSystem(token) {
        const res = http.post(`${BASE_URL}${API_PREFIX}/queue/enter`, JSON.stringify({ waiting_token: token }), {
            headers: { ...baseHeaders, 'Idempotency-Key': uuidv4() },
            tags: { name: 'queue_enter', part: PART_ID, test: '30k' }
        });
        const success = check(res, { 'enter ok': (r) => r.status === 200 });
        queueEnterFailRate.add(!success);
        return success ? res.json('reservation_token') : null;
    }

    function createReservation(token, eventId) {
        const res = http.post(`${BASE_URL}${API_PREFIX}/reservations`, JSON.stringify({
            event_id: eventId,
            seat_ids: ["A-" + (Math.floor(Math.random() * 1000) + 1), "A-" + (Math.floor(Math.random() * 1000) + 1)],
            quantity: 2
        }), {
            headers: { ...baseHeaders, 'Authorization': `Bearer ${token}`, 'Idempotency-Key': uuidv4() },
            tags: { name: 'create_reservation', part: PART_ID, test: '30k' }
        });
        const success = check(res, { 'reservation ok': (r) => r.status === 201 || r.status === 200 });
        reservationFailRate.add(!success);
        return success ? res.json('reservation_id') : null;
    }

    export function fullScenario() {
        const queueData = joinQueue();
        if (!queueData) return;
        if (!pollQueueStatus(queueData.waiting_token)) return;
        const token = enterSystem(queueData.waiting_token);
        if (!token) return;
        sleep(Math.random() * 2 + 1);
        if (createReservation(token, queueData.eventId)) {
            completedFlows.add(1);
        }
        sleep(Math.random() * 1 + 0.5);
    }
---
# Parts 2-6 (동일한 로직, 태그만 다름)
apiVersion: v1
kind: ConfigMap
metadata:
  name: k6-script-30k-part2
  namespace: load-test
  labels:
    test: 30k-distributed
    part: "2"
data:
  script.js: |
    import http from 'k6/http';
    import { check, sleep } from 'k6';
    import { Rate, Counter } from 'k6/metrics';

    const queueJoinFailRate = new Rate('queue_join_fail_rate');
    const queueStatusFailRate = new Rate('queue_status_fail_rate');
    const queueEnterFailRate = new Rate('queue_enter_fail_rate');
    const reservationFailRate = new Rate('reservation_fail_rate');
    const completedFlows = new Counter('completed_flows');

    function uuidv4() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    export const options = {
        scenarios: {
          full_success_flow: {
              executor: 'ramping-arrival-rate',
              startRate: 0,
              timeUnit: '1s',
              preAllocatedVUs: 200,
              maxVUs: 2500,
              stages: [
                  { duration: '3m', target: 2000 },
                  { duration: '5m', target: 5000 },
                  { duration: '15m', target: 5000 },
                  { duration: '3m', target: 0 },
              ],
              exec: 'fullScenario',
              tags: { part: '2', test: '30k' }
          }
        }
    };

    const BASE_URL = __ENV.TARGET_BASE_URL;
    const API_PREFIX = '/api/v1';
    const PART_ID = '2';
    const baseHeaders = { 'Content-Type': 'application/json' };

    function joinQueue() {
        const userId = `u${uuidv4()}`;
        const eventId = `evt_${Math.floor(Math.random() * 100) + 1}`;
        const res = http.post(`${BASE_URL}${API_PREFIX}/queue/join`, JSON.stringify({ user_id: userId, event_id: eventId }), {
            headers: { ...baseHeaders, 'Idempotency-Key': uuidv4() },
            timeout: '30s', tags: { name: 'queue_join', part: PART_ID, test: '30k' }
        });
        const success = check(res, { 'join ok': (r) => r.status === 202 });
        queueJoinFailRate.add(!success);
        return success ? { waiting_token: res.json('waiting_token'), userId, eventId } : null;
    }

    function pollQueueStatus(token) {
        for (let i = 0; i < 30; i++) {
            sleep(Math.random() * 2 + 2);
            const res = http.get(`${BASE_URL}${API_PREFIX}/queue/status?token=${token}`, { tags: { name: 'queue_status', part: PART_ID, test: '30k' } });
            if (res.status === 200 && res.json('status') === "ready") return true;
            queueStatusFailRate.add(res.status !== 200);
        }
        return false;
    }

    function enterSystem(token) {
        const res = http.post(`${BASE_URL}${API_PREFIX}/queue/enter`, JSON.stringify({ waiting_token: token }), {
            headers: { ...baseHeaders, 'Idempotency-Key': uuidv4() }, tags: { name: 'queue_enter', part: PART_ID, test: '30k' }
        });
        const success = check(res, { 'enter ok': (r) => r.status === 200 });
        queueEnterFailRate.add(!success);
        return success ? res.json('reservation_token') : null;
    }

    function createReservation(token, eventId) {
        const res = http.post(`${BASE_URL}${API_PREFIX}/reservations`, JSON.stringify({
            event_id: eventId, seat_ids: ["A-" + (Math.floor(Math.random() * 1000) + 1), "A-" + (Math.floor(Math.random() * 1000) + 1)], quantity: 2
        }), {
            headers: { ...baseHeaders, 'Authorization': `Bearer ${token}`, 'Idempotency-Key': uuidv4() },
            tags: { name: 'create_reservation', part: PART_ID, test: '30k' }
        });
        const success = check(res, { 'reservation ok': (r) => r.status === 201 || r.status === 200 });
        reservationFailRate.add(!success);
        return success;
    }

    export function fullScenario() {
        const queueData = joinQueue();
        if (!queueData || !pollQueueStatus(queueData.waiting_token)) return;
        const token = enterSystem(queueData.waiting_token);
        if (!token) return;
        sleep(Math.random() * 2 + 1);
        if (createReservation(token, queueData.eventId)) completedFlows.add(1);
        sleep(Math.random() * 1 + 0.5);
    }
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: k6-script-30k-part3
  namespace: load-test
  labels:
    test: 30k-distributed
    part: "3"
data:
  script.js: |
    import http from 'k6/http';
    import { check, sleep } from 'k6';
    import { Rate, Counter } from 'k6/metrics';
    const queueJoinFailRate = new Rate('queue_join_fail_rate');
    const completedFlows = new Counter('completed_flows');
    function uuidv4() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { const r = Math.random() * 16 | 0; const v = c === 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); }
    export const options = { scenarios: { full_success_flow: { executor: 'ramping-arrival-rate', startRate: 0, timeUnit: '1s', preAllocatedVUs: 200, maxVUs: 2500, stages: [{ duration: '3m', target: 2000 }, { duration: '5m', target: 5000 }, { duration: '15m', target: 5000 }, { duration: '3m', target: 0 }], exec: 'fullScenario', tags: { part: '3', test: '30k' } } } };
    const BASE_URL = __ENV.TARGET_BASE_URL; const API_PREFIX = '/api/v1'; const PART_ID = '3'; const baseHeaders = { 'Content-Type': 'application/json' };
    function joinQueue() { const userId = `u${uuidv4()}`; const eventId = `evt_${Math.floor(Math.random() * 100) + 1}`; const res = http.post(`${BASE_URL}${API_PREFIX}/queue/join`, JSON.stringify({ user_id: userId, event_id: eventId }), { headers: { ...baseHeaders, 'Idempotency-Key': uuidv4() }, timeout: '30s', tags: { name: 'queue_join', part: PART_ID, test: '30k' } }); const success = check(res, { 'join ok': (r) => r.status === 202 }); queueJoinFailRate.add(!success); return success ? { waiting_token: res.json('waiting_token'), userId, eventId } : null; }
    function pollQueueStatus(token) { for (let i = 0; i < 30; i++) { sleep(Math.random() * 2 + 2); const res = http.get(`${BASE_URL}${API_PREFIX}/queue/status?token=${token}`, { tags: { name: 'queue_status', part: PART_ID, test: '30k' } }); if (res.status === 200 && res.json('status') === "ready") return true; } return false; }
    function enterSystem(token) { const res = http.post(`${BASE_URL}${API_PREFIX}/queue/enter`, JSON.stringify({ waiting_token: token }), { headers: { ...baseHeaders, 'Idempotency-Key': uuidv4() }, tags: { name: 'queue_enter', part: PART_ID, test: '30k' } }); return check(res, { 'enter ok': (r) => r.status === 200 }) ? res.json('reservation_token') : null; }
    function createReservation(token, eventId) { const res = http.post(`${BASE_URL}${API_PREFIX}/reservations`, JSON.stringify({ event_id: eventId, seat_ids: ["A-" + (Math.floor(Math.random() * 1000) + 1), "A-" + (Math.floor(Math.random() * 1000) + 1)], quantity: 2 }), { headers: { ...baseHeaders, 'Authorization': `Bearer ${token}`, 'Idempotency-Key': uuidv4() }, tags: { name: 'create_reservation', part: PART_ID, test: '30k' } }); return check(res, { 'reservation ok': (r) => r.status === 201 || r.status === 200 }); }
    export function fullScenario() { const queueData = joinQueue(); if (!queueData || !pollQueueStatus(queueData.waiting_token)) return; const token = enterSystem(queueData.waiting_token); if (!token) return; sleep(Math.random() * 2 + 1); if (createReservation(token, queueData.eventId)) completedFlows.add(1); sleep(Math.random() * 1 + 0.5); }
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: k6-script-30k-part4
  namespace: load-test
  labels:
    test: 30k-distributed
    part: "4"
data:
  script.js: |
    import http from 'k6/http';
    import { check, sleep } from 'k6';
    import { Rate, Counter } from 'k6/metrics';
    const queueJoinFailRate = new Rate('queue_join_fail_rate');
    const completedFlows = new Counter('completed_flows');
    function uuidv4() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { const r = Math.random() * 16 | 0; const v = c === 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); }
    export const options = { scenarios: { full_success_flow: { executor: 'ramping-arrival-rate', startRate: 0, timeUnit: '1s', preAllocatedVUs: 200, maxVUs: 2500, stages: [{ duration: '3m', target: 2000 }, { duration: '5m', target: 5000 }, { duration: '15m', target: 5000 }, { duration: '3m', target: 0 }], exec: 'fullScenario', tags: { part: '4', test: '30k' } } } };
    const BASE_URL = __ENV.TARGET_BASE_URL; const API_PREFIX = '/api/v1'; const PART_ID = '4'; const baseHeaders = { 'Content-Type': 'application/json' };
    function joinQueue() { const userId = `u${uuidv4()}`; const eventId = `evt_${Math.floor(Math.random() * 100) + 1}`; const res = http.post(`${BASE_URL}${API_PREFIX}/queue/join`, JSON.stringify({ user_id: userId, event_id: eventId }), { headers: { ...baseHeaders, 'Idempotency-Key': uuidv4() }, timeout: '30s', tags: { name: 'queue_join', part: PART_ID, test: '30k' } }); const success = check(res, { 'join ok': (r) => r.status === 202 }); queueJoinFailRate.add(!success); return success ? { waiting_token: res.json('waiting_token'), userId, eventId } : null; }
    function pollQueueStatus(token) { for (let i = 0; i < 30; i++) { sleep(Math.random() * 2 + 2); const res = http.get(`${BASE_URL}${API_PREFIX}/queue/status?token=${token}`, { tags: { name: 'queue_status', part: PART_ID, test: '30k' } }); if (res.status === 200 && res.json('status') === "ready") return true; } return false; }
    function enterSystem(token) { const res = http.post(`${BASE_URL}${API_PREFIX}/queue/enter`, JSON.stringify({ waiting_token: token }), { headers: { ...baseHeaders, 'Idempotency-Key': uuidv4() }, tags: { name: 'queue_enter', part: PART_ID, test: '30k' } }); return check(res, { 'enter ok': (r) => r.status === 200 }) ? res.json('reservation_token') : null; }
    function createReservation(token, eventId) { const res = http.post(`${BASE_URL}${API_PREFIX}/reservations`, JSON.stringify({ event_id: eventId, seat_ids: ["A-" + (Math.floor(Math.random() * 1000) + 1), "A-" + (Math.floor(Math.random() * 1000) + 1)], quantity: 2 }), { headers: { ...baseHeaders, 'Authorization': `Bearer ${token}`, 'Idempotency-Key': uuidv4() }, tags: { name: 'create_reservation', part: PART_ID, test: '30k' } }); return check(res, { 'reservation ok': (r) => r.status === 201 || r.status === 200 }); }
    export function fullScenario() { const queueData = joinQueue(); if (!queueData || !pollQueueStatus(queueData.waiting_token)) return; const token = enterSystem(queueData.waiting_token); if (!token) return; sleep(Math.random() * 2 + 1); if (createReservation(token, queueData.eventId)) completedFlows.add(1); sleep(Math.random() * 1 + 0.5); }
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: k6-script-30k-part5
  namespace: load-test
  labels:
    test: 30k-distributed
    part: "5"
data:
  script.js: |
    import http from 'k6/http';
    import { check, sleep } from 'k6';
    import { Rate, Counter } from 'k6/metrics';
    const queueJoinFailRate = new Rate('queue_join_fail_rate');
    const completedFlows = new Counter('completed_flows');
    function uuidv4() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { const r = Math.random() * 16 | 0; const v = c === 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); }
    export const options = { scenarios: { full_success_flow: { executor: 'ramping-arrival-rate', startRate: 0, timeUnit: '1s', preAllocatedVUs: 200, maxVUs: 2500, stages: [{ duration: '3m', target: 2000 }, { duration: '5m', target: 5000 }, { duration: '15m', target: 5000 }, { duration: '3m', target: 0 }], exec: 'fullScenario', tags: { part: '5', test: '30k' } } } };
    const BASE_URL = __ENV.TARGET_BASE_URL; const API_PREFIX = '/api/v1'; const PART_ID = '5'; const baseHeaders = { 'Content-Type': 'application/json' };
    function joinQueue() { const userId = `u${uuidv4()}`; const eventId = `evt_${Math.floor(Math.random() * 100) + 1}`; const res = http.post(`${BASE_URL}${API_PREFIX}/queue/join`, JSON.stringify({ user_id: userId, event_id: eventId }), { headers: { ...baseHeaders, 'Idempotency-Key': uuidv4() }, timeout: '30s', tags: { name: 'queue_join', part: PART_ID, test: '30k' } }); const success = check(res, { 'join ok': (r) => r.status === 202 }); queueJoinFailRate.add(!success); return success ? { waiting_token: res.json('waiting_token'), userId, eventId } : null; }
    function pollQueueStatus(token) { for (let i = 0; i < 30; i++) { sleep(Math.random() * 2 + 2); const res = http.get(`${BASE_URL}${API_PREFIX}/queue/status?token=${token}`, { tags: { name: 'queue_status', part: PART_ID, test: '30k' } }); if (res.status === 200 && res.json('status') === "ready") return true; } return false; }
    function enterSystem(token) { const res = http.post(`${BASE_URL}${API_PREFIX}/queue/enter`, JSON.stringify({ waiting_token: token }), { headers: { ...baseHeaders, 'Idempotency-Key': uuidv4() }, tags: { name: 'queue_enter', part: PART_ID, test: '30k' } }); return check(res, { 'enter ok': (r) => r.status === 200 }) ? res.json('reservation_token') : null; }
    function createReservation(token, eventId) { const res = http.post(`${BASE_URL}${API_PREFIX}/reservations`, JSON.stringify({ event_id: eventId, seat_ids: ["A-" + (Math.floor(Math.random() * 1000) + 1), "A-" + (Math.floor(Math.random() * 1000) + 1)], quantity: 2 }), { headers: { ...baseHeaders, 'Authorization': `Bearer ${token}`, 'Idempotency-Key': uuidv4() }, tags: { name: 'create_reservation', part: PART_ID, test: '30k' } }); return check(res, { 'reservation ok': (r) => r.status === 201 || r.status === 200 }); }
    export function fullScenario() { const queueData = joinQueue(); if (!queueData || !pollQueueStatus(queueData.waiting_token)) return; const token = enterSystem(queueData.waiting_token); if (!token) return; sleep(Math.random() * 2 + 1); if (createReservation(token, queueData.eventId)) completedFlows.add(1); sleep(Math.random() * 1 + 0.5); }
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: k6-script-30k-part6
  namespace: load-test
  labels:
    test: 30k-distributed
    part: "6"
data:
  script.js: |
    import http from 'k6/http';
    import { check, sleep } from 'k6';
    import { Rate, Counter } from 'k6/metrics';
    const queueJoinFailRate = new Rate('queue_join_fail_rate');
    const completedFlows = new Counter('completed_flows');
    function uuidv4() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { const r = Math.random() * 16 | 0; const v = c === 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); }
    export const options = { scenarios: { full_success_flow: { executor: 'ramping-arrival-rate', startRate: 0, timeUnit: '1s', preAllocatedVUs: 200, maxVUs: 2500, stages: [{ duration: '3m', target: 2000 }, { duration: '5m', target: 5000 }, { duration: '15m', target: 5000 }, { duration: '3m', target: 0 }], exec: 'fullScenario', tags: { part: '6', test: '30k' } } } };
    const BASE_URL = __ENV.TARGET_BASE_URL; const API_PREFIX = '/api/v1'; const PART_ID = '6'; const baseHeaders = { 'Content-Type': 'application/json' };
    function joinQueue() { const userId = `u${uuidv4()}`; const eventId = `evt_${Math.floor(Math.random() * 100) + 1}`; const res = http.post(`${BASE_URL}${API_PREFIX}/queue/join`, JSON.stringify({ user_id: userId, event_id: eventId }), { headers: { ...baseHeaders, 'Idempotency-Key': uuidv4() }, timeout: '30s', tags: { name: 'queue_join', part: PART_ID, test: '30k' } }); const success = check(res, { 'join ok': (r) => r.status === 202 }); queueJoinFailRate.add(!success); return success ? { waiting_token: res.json('waiting_token'), userId, eventId } : null; }
    function pollQueueStatus(token) { for (let i = 0; i < 30; i++) { sleep(Math.random() * 2 + 2); const res = http.get(`${BASE_URL}${API_PREFIX}/queue/status?token=${token}`, { tags: { name: 'queue_status', part: PART_ID, test: '30k' } }); if (res.status === 200 && res.json('status') === "ready") return true; } return false; }
    function enterSystem(token) { const res = http.post(`${BASE_URL}${API_PREFIX}/queue/enter`, JSON.stringify({ waiting_token: token }), { headers: { ...baseHeaders, 'Idempotency-Key': uuidv4() }, tags: { name: 'queue_enter', part: PART_ID, test: '30k' } }); return check(res, { 'enter ok': (r) => r.status === 200 }) ? res.json('reservation_token') : null; }
    function createReservation(token, eventId) { const res = http.post(`${BASE_URL}${API_PREFIX}/reservations`, JSON.stringify({ event_id: eventId, seat_ids: ["A-" + (Math.floor(Math.random() * 1000) + 1), "A-" + (Math.floor(Math.random() * 1000) + 1)], quantity: 2 }), { headers: { ...baseHeaders, 'Authorization': `Bearer ${token}`, 'Idempotency-Key': uuidv4() }, tags: { name: 'create_reservation', part: PART_ID, test: '30k' } }); return check(res, { 'reservation ok': (r) => r.status === 201 || r.status === 200 }); }
    export function fullScenario() { const queueData = joinQueue(); if (!queueData || !pollQueueStatus(queueData.waiting_token)) return; const token = enterSystem(queueData.waiting_token); if (!token) return; sleep(Math.random() * 2 + 1); if (createReservation(token, queueData.eventId)) completedFlows.add(1); sleep(Math.random() * 1 + 0.5); }
